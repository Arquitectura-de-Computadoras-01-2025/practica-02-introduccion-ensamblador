<!DOCTYPE html>

<html>
  <head>
    <meta
      name="viewport"
      content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes"
    />
    <meta name="theme-color" content="#4F7DC9" />
    <meta charset="UTF-8" />
    <title>
      Laboratorio 3: Introducci贸n a ensamblador y modos de direccionamiento
    </title>
    <link
      rel="stylesheet"
      href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono"
    />
    <link
      rel="stylesheet"
      href="//fonts.googleapis.com/icon?family=Material+Icons"
    />
    <link
      rel="stylesheet"
      href="https://storage.googleapis.com/claat-public/codelab-elements.css"
    />
    <style>
      .success {
        color: #1e8e3e;
      }
      .error {
        color: red;
      }
    </style>
  </head>
  <body>
    <google-codelab-analytics
      gaid="UA-49880327-14"
      ga4id=""
    ></google-codelab-analytics>
    <google-codelab
      codelab-gaid=""
      codelab-ga4id=""
      id="laboratorio-03-arquitectura"
      title="Laboratorio 3: Introducci贸n a ensamblador y modos de direccionamiento"
      environment="web"
      feedback-link=""
    >
      <google-codelab-step label="Objetivos" duration="0">
        <ul>
          <li>
            Comprender la sintaxis b谩sica y los componentes esenciales del
            c贸digo en ensamblador X86.
          </li>
          <li>
            Identificar y describir la funci贸n de los registros comunes en la
            arquitectura X86.
          </li>
          <li>
            Aprender a escribir instrucciones b谩sicas en ensamblador X86 y
            compilarlas utilizando NASM.
          </li>
          <li>
            Ejecutar y depurar programas en ensamblador usando DOSBOX y
            debug.exe.
          </li>
          <li>
            Explorar y diferenciar los distintos modos de direccionamiento en
            ensamblador X86 y su aplicaci贸n pr谩ctica.
          </li>
        </ul>
      </google-codelab-step>

      <google-codelab-step label="Introducci贸n a Ensamblador" duration="0">
        <p>
          La programaci贸n en lenguaje ensamblador es una forma de programar a
          bajo nivel que se comunica directamente con el microprocesador de una
          computadora. En contraste con los lenguajes de alto nivel, como Python
          o Java, que est谩n dise帽ados para ser m谩s f谩ciles de entender y
          escribir, el ensamblador trabaja a un nivel m谩s cercano al hardware
          f铆sico de la m谩quina.
        </p>
        <h2 is-upgraded><strong>Caracter铆sticas principales:</strong></h2>
        <ul>
          <li>
            <strong>Programaci贸n de bajo nivel</strong>: El lenguaje ensamblador
            se considera de bajo nivel debido a que las instrucciones que
            escribe el programador se traducen directamente a c贸digo m谩quina, el
            cual es el lenguaje entendido por la CPU (Unidad Central de
            Procesamiento). Esta caracter铆stica proporciona un mayor control
            sobre el hardware y permite optimizar el rendimiento de los
            programas.
          </li>
          <li>
            <strong>Control directo del hardware</strong>: Una de las ventajas
            principales de programar en ensamblador es la capacidad de controlar
            directamente el hardware de la computadora. Esto significa que se
            pueden escribir programas que interact煤en con la CPU, la memoria y
            otros dispositivos perif茅ricos de manera precisa y eficiente.
          </li>
        </ul>
        <h2 is-upgraded>Sintaxis:</h2>
        <p>
          El lenguaje de ensamblador X86 tiene una estructura y sintaxis
          espec铆fica que permite a los programadores escribir instrucciones que
          la CPU puede ejecutar directamente. Comprender esta sintaxis es
          crucial para desarrollar programas eficientes y funcionales. A
          continuaci贸n se describen los componentes clave de la sintaxis del
          ensamblador X86:
        </p>
        <p class="image-container">
          <img alt="Sintaxis" src="img/31688d5f34b8f87e.jpeg" />
        </p>
        <ol type="1">
          <li>
            <strong>Directivas:</strong> Las directivas son comandos que le
            indican al ensamblador c贸mo procesar el c贸digo. No son ejecutadas
            por la CPU, sino que preparan el entorno de ejecuci贸n. Por ejemplo,
            pueden definir constantes, reservar espacio en memoria o incluso
            controlar el proceso de ensamblaje.
          </li>
          <li>
            <strong>Secciones:</strong> En ensamblador X86, el c贸digo y los
            datos se organizan en secciones:
            <ul>
              <li>
                <strong>section .text</strong>: Esta es la secci贸n principal
                donde se escribe el c贸digo ejecutable. Aqu铆 se colocan todas las
                instrucciones que la CPU ejecutar谩.
              </li>
              <li>
                <strong>section .data</strong>: Utilizada para declarar
                variables est谩ticas o constantes que no cambian durante la
                ejecuci贸n del programa. Esta secci贸n almacena los datos que las
                instrucciones en la secci贸n .text manipular谩n.
              </li>
            </ul>
          </li>
          <li>
            <strong>Etiquetas:</strong> Las etiquetas son identificadores que
            marcan puntos espec铆ficos en el c贸digo, como el inicio de una
            funci贸n o un loop. Funcionan como marcadores que pueden ser
            referenciados por instrucciones de salto y llamadas a funciones,
            facilitando la navegaci贸n y organizaci贸n del c贸digo.
          </li>
          <li>
            <strong>Instrucciones:</strong> Las instrucciones son comandos que
            el procesador ejecuta directamente. Incluyen operaciones
            aritm茅ticas, de manejo de datos, control de flujo, entre otros. Cada
            instrucci贸n tiene un prop贸sito espec铆fico y se expresa en la forma
            m谩s cercana al lenguaje de la m谩quina que es comprensible para los
            humanos.
          </li>
          <li>
            <strong>Operandos:</strong> Los operandos son los valores con los
            que trabajan las instrucciones. Pueden ser inmediatos (valores
            directos), registros, o ubicaciones de memoria. Los operandos
            determinan las entradas y salidas de las instrucciones y son
            esenciales para la manipulaci贸n de datos.
          </li>
        </ol>
      </google-codelab-step>

      <google-codelab-step label="Registros de datos" duration="0">
        <p>
          Los registros de datos son componentes fundamentales en Ensamblador,
          ya que se usan en el manejo de operaciones aritm茅ticas y el
          almacenamiento temporal de datos. Cada registro de datos es de 16 bits
          de longitud y puede ser tratado como dos registros de 8 bits
          independientes, es decir, est谩n compuesto por dos subregistros de 8
          bits: parte alta y parte baja.
        </p>
        <p>
          Estos registros residen en la Unidad de Ejecuci贸n (EU), los cuales
          son:
        </p>
        <p class="image-container">
          <img alt="Registros" src="img/f0755d32de9a5fa4.jpeg" />
        </p>
        <ol type="1">
          <li>
            <strong>AX (Acumulador):</strong> Este registro se destaca como el
            principal registro de trabajo. Se utiliza para almacenar resultados
            de operaciones aritm茅ticas y otras operaciones.
          </li>
          <li>
            <strong>BX (Registro Base):</strong> BX se utiliza como un registro
            de base para direccionamientos de memoria. Es crucial para indicar
            d贸nde se almacenar谩n o recuperar谩n bloques de datos que ser谩n
            procesados por el programa.
          </li>
          <li>
            <strong>CX (Contador):</strong> CX cumple una doble funci贸n como
            contador y almacenador de datos. Se utiliza para llevar el conteo de
            ciclos repetitivos en un programa con instrucciones de bucle, adem谩s
            de almacenar temporalmente datos para su manipulaci贸n.
          </li>
          <li>
            <strong>DX (Registro de Datos):</strong> DX desempe帽a un papel
            importante en operaciones aritm茅ticas de multiplicaci贸n y divisi贸n.
            Se utiliza para manejar los operandos y los resultados de estas
            operaciones. Adem谩s, en algunas operaciones, DX almacena la
            direcci贸n de entrada/salida (E/S), lo que lo convierte en un
            registro vers谩til en el manejo de datos y control de dispositivos.
          </li>
        </ol>
      </google-codelab-step>

      <google-codelab-step
        label="Pasos para la compilaci贸n y DEBUG"
        duration="0"
      >
        <ol type="1">
          <li>
            Guardar el c贸digo en lenguaje ensamblador x86 en un archivo con
            extensi贸n <strong><code>.asm</code></strong
            >. Este archivo contendr谩 el programa en ensamblador.
          </li>
          <li>
            Ensamblar el archivo guardado ejecutando el siguiente comando:
            <pre><code language="language-bash" class="language-bash">nasm -f bin &lt;nombre&gt;.asm -o &lt;nombre&gt;.com
</code></pre>
            Este comando genera un archivo ejecutable con extensi贸n
            <strong><code>.com</code></strong> con el nombre indicado en el
            comando.
          </li>
          <li>
            Abrir DOSBox, donde se podr谩 ejecutar y depurar el programa antes
            ensamblado. Se puede abrir DOSBox desde la terminal ejecutando el
            siguiente comando:
            <pre><code language="language-bash" class="language-bash">dosbox .
</code></pre>
          </li>
          <li>
            Una vez que DOSBox est茅 abierto, ingresar el siguiente comando en el
            prompt para iniciar el depurador y cargar el programa:
            <pre><code language="language-bash" class="language-bash">debug.exe &lt;nombre&gt;.com
</code></pre>
            Esto abrir谩 el depurador de DOSBox y cargar谩s tu programa
            ensamblador para su depuraci贸n.
          </li>
        </ol>
      </google-codelab-step>

      <google-codelab-step label="Comandos 煤tiles para DEBUG" duration="0">
        <ul>
          <li>
            <strong><code>r</code></strong
            ><strong> - Mostrar Registros:</strong> Muestra el estado actual de
            los registros de la CPU, lo que proporciona informaci贸n sobre los
            valores almacenados en los registros de la CPU.
          </li>
          <li>
            <strong><code>t</code></strong
            ><strong> - Ejecutar Instrucci贸n:</strong> Ejecuta una sola
            instrucci贸n del programa, permitiendo un paso a trav茅s del c贸digo
            para inspeccionar su ejecuci贸n paso a paso.
          </li>
          <li>
            <strong><code>t n</code></strong
            ><strong> - Ejecutar Instrucciones:</strong> Ejecuta un n煤mero
            espec铆fico (<strong><code>n</code></strong
            >) de instrucciones del programa, lo que permite avanzar r谩pidamente
            a trav茅s del c贸digo.
          </li>
          <li>
            <strong><code>g</code></strong
            ><strong> - Ejecutar Programa:</strong> Ejecuta todo el programa de
            forma continua hasta que alcanza un punto de interrupci贸n o
            finaliza, lo que facilita la ejecuci贸n completa del programa.
          </li>
          <li>
            <strong><code>d 200</code></strong
            ><strong> - Ver Memoria:</strong> Muestra el estado de la memoria en
            la direcci贸n espec铆fica <strong><code>200h</code></strong
            >, lo que permite inspeccionar el contenido de la memoria en esa
            ubicaci贸n.
          </li>
          <li>
            <strong><code>q</code></strong
            ><strong> - Salir:</strong> Sale del depurador DEBUG, regresando al
            prompt de la l铆nea de comandos, lo que finaliza la sesi贸n de
            depuraci贸n.
          </li>
        </ul>
      </google-codelab-step>

      <google-codelab-step
        label="Direccionamiento: Instrucci贸n 
MOV"
        duration="0"
      >
        <h2 is-upgraded><strong>Concepto de Direccionamiento</strong></h2>
        <p>
          El direccionamiento en ensamblador se refiere a la manera en que se
          accede a los datos necesarios para ejecutar una instrucci贸n. Los modos
          de direccionamiento determinan la ubicaci贸n de los operandos que una
          instrucci贸n puede utilizar, ya sea en un registro, en memoria o como
          un valor inmediato. Estos modos son fundamentales para entender c贸mo
          se manipulan los datos dentro de un programa en ensamblador.
        </p>
        <h2 is-upgraded><strong>Instrucci贸n MOV</strong></h2>
        <p>
          La instrucci贸n <strong><code>MOV</code></strong> es una de las m谩s
          b谩sicas y utilizadas en ensamblador X86. Su funci贸n es mover datos de
          un lugar a otro. La sintaxis general es:
        </p>
        <pre><code language="language-nasm" class="language-nasm">MOV destino, fuente
</code></pre>
        <p>
          Donde el <strong><code>destino</code></strong> no puede ser un valor
          inmediato, sino m谩s bien un registro o direcci贸n de memoria.
        </p>
        <h2 is-upgraded>
          <strong>Directivas de Tama帽o: </strong
          ><strong><code>byte</code></strong
          ><strong>, </strong><strong><code>word</code></strong
          ><strong>, y </strong><strong><code>dword</code></strong>
        </h2>
        <p>
          En ensamblador X86, es crucial especificar el tama帽o de los datos con
          los que se est谩 trabajando. Las directivas de tama帽o byte, word, y
          dword se utilizan para este prop贸sito:
        </p>
        <ul>
          <li>
            <strong>byte:</strong> Especifica que los datos son de 1 byte u 8
            bits.
          </li>
          <li>
            <strong>word:</strong> Especifica que los datos son de 2 bytes o 16
            bits.
          </li>
          <li>
            <strong>dword:</strong> Especifica que los datos son de 4 bytes o 32
            bits.
          </li>
        </ul>
        <p>
          La elecci贸n entre estas directivas depende del tama帽o de los datos que
          se necesitan mover. Usar la directiva de tama帽o adecuada es crucial
          para asegurar que el programa funcione correctamente y que no se
          produzcan errores de acceso a memoria.
        </p>
      </google-codelab-step>

      <google-codelab-step label="Modos de direccionamiento" duration="0">
        <p>
          Los modos de direccionamiento en ensamblador son m茅todos que
          especifican c贸mo una instrucci贸n obtiene los operandos necesarios para
          su ejecuci贸n. Cada modo de direccionamiento ofrece un mecanismo
          diferente para acceder a los datos, ya sea directamente en el c贸digo,
          a trav茅s de registros, o mediante direcciones de memoria. La elecci贸n
          del modo de direccionamiento afecta la flexibilidad, la eficiencia y
          el tama帽o del c贸digo de la m谩quina.
        </p>
        <p>
          Entre los principales modos de direccionamiento tenemos los
          siguientes:
        </p>
        <h2 is-upgraded>Modo de direccionamiento inmediato</h2>
        <p>
          El modo de direccionamiento inmediato es uno de los m谩s simples y
          directos en ensamblador. En este modo, el operando es un valor
          constante o literal que est谩 codificado directamente en la
          instrucci贸n. Este valor no se almacena en memoria o en un registro,
          sino que forma parte de la propia instrucci贸n
        </p>
        <p>
          Es posible realizar el direccionamiento inmediato con varios tipos de
          datos, por ejemplo:
        </p>
        <ol type="1">
          <li><strong>Decimales</strong></li>
        </ol>
        <pre><code language="language-nasm" class="language-nasm">MOV AH, 12d
</code></pre>
        <p>
          Esta instrucci贸n carga el valor decimal <code>12</code> en el registro
          <code>AH</code> (parte alta del registro <code>AX</code>).
        </p>
        <ol type="1">
          <li><strong>Hexadecimales</strong></li>
        </ol>
        <pre><code language="language-nasm" class="language-nasm">MOV AL, 14ECh;
</code></pre>
        <p>
          El c贸digo anterior carga en el registro de 8 bits <code>AL</code> el
          valor hexadecimal <code>14EC</code>.
        </p>
        <p>
          O si se desea almacenar un valor hexadecimal que comience por una
          letra, por ejemplo <code>FF</code>, es necesario anteponerle el n煤mero
          cero, de lo contrario se obtendr谩 un error.
        </p>
        <pre><code language="language-nasm" class="language-nasm">MOV AL, 0FFh
</code></pre>
        <ol type="1">
          <li><strong>Binarios</strong></li>
        </ol>
        <pre><code language="language-nasm" class="language-nasm">MOV BH, 10010b
</code></pre>
        <p>
          Con esta instrucci贸n se ha cargado en el registro <code>BH</code> el
          valor binario <code>10010</code> .
        </p>
        <aside class="special">
          <p>
             Notar que las letras <strong>d</strong>, <strong>h</strong> y
            <strong>b</strong> al final de los n煤meros a guardar describen el
            sistema de numeraci贸n que se utilizar谩.
          </p>
        </aside>
        <ol type="1">
          <li><strong>Caracteres</strong></li>
        </ol>
        <pre><code language="language-nasm" class="language-nasm">MOV BL, &#34;A&#34;
</code></pre>
        <p>
          Con esta instrucci贸n, se carga el c贸digo <strong>ASCII</strong> de la
          letra <code>A</code> en el registro <code>BL</code> .
        </p>
        <h2 is-upgraded>Modo de direccionamiento por registro</h2>
        <p>
          En este modo de direccionamiento, usaremos los registros como
          operandos, de manera que pasemos el dato contenido de un registro a
          otro. Hay que considerar que el registro que usemos como fuente
          conservara su valor original, mientras que el registro de destino
          copiara el valor de la fuente. Por otro lado, una cosa muy importante
          sobre este modo es que ambos registros deben tener el mismo tama帽o.
        </p>
        <p>Por ejemplo:</p>
        <pre><code language="language-nasm" class="language-nasm">MOV CX, AX
</code></pre>
        <p>
          En esta instrucci贸n, se mover谩 el contenido del registro AX al
          registro CX. En este caso, AX y CX son los operandos y al realizarse
          la operaci贸n ambos registros contendr谩n el valor que AX tenia
          originalmente.
        </p>
        <h2 is-upgraded>Modo de direccionamiento absoluto</h2>
        <p>
          En el modo de direccionamiento absoluto adem谩s de registros tambi茅n
          usamos direcciones de memoria para el manejo de datos, ya sea como
          fuente o como destino. Para hacerlo indicamos la direcci贸n que
          deseamos usar entre corchetes.
        </p>
        <pre><code language="language-nasm" class="language-nasm">; Direccionamiento con registros de 8 bits/1 byte
  MOV [200h], CH; de registro a memoria
  MOV AH, [200h]; de memoria a registro
</code></pre>
        <p>
          Cada direcci贸n de memoria almacena 1 byte de informaci贸n. Si deseamos
          almacenar valores mayores los bytes excedentes se guardaran en las
          direcciones siguientes utilizando la notaci贸n little endian.
        </p>
        <pre><code language="language-nasm" class="language-nasm">; DX actualmente tiene como valor 1241h
 
; Direccionamiento con registros de 16 bits/2 bytes
   MOV [210h], DX; de registro a memoria
   MOV BX, [210h]; de memoria a registro
</code></pre>
        <p>
          En el ejemplo anterior, en la direcci贸n hexadecimal
          <code>210</code> se guardara el valor hexadecimal <code>41</code> y la
          direcci贸n <code>211</code> tendr谩 el valor hexadecimal
          <code>12</code> .
        </p>
        <p>
          Al pasarlo de memoria a registro, el contenido de la direcci贸n
          <code>210h</code> se guarda en la parte baja de <code>BX</code> y el
          de la direcci贸n <code>211h</code> en la parte alta. Como resultado
          tanto <code>DX</code> como <code>BX</code> ****tendr谩n el mismo
          contenido.
        </p>
        <p>
          Es importante se帽alar que el comando MOV
          <strong
            >no permite usar dos direcciones de memoria como operandos al mismo
            tiempo</strong
          >, por lo que si deseamos pasar un dato de una direcci贸n de memoria a
          otra siempre debemos usar un registro como intermediario.
        </p>
        <h2 is-upgraded>Modo de direccionamiento indirecto</h2>
        <p>
          El modo de direccionamiento indirecto permite acceder a los datos
          mediante el uso de registros que contienen direcciones de memoria. En
          lugar de especificar un operando directamente en la instrucci贸n, se
          utiliza el valor dentro de un registro como referencia a la memoria
          donde se encuentra el dato. Este modo es especialmente 煤til para
          manipular colecciones de datos como arrays o para implementar
          estructuras de datos complejas que requieren acceso din谩mico.
        </p>
        <p>
          En el direccionamiento indirecto, la CPU toma el valor de un registro,
          lo trata como una direcci贸n de memoria y accede al contenido de esa
          direcci贸n. Esto permite que las instrucciones trabajen con datos cuya
          ubicaci贸n exacta en memoria puede no ser conocida en tiempo de
          compilaci贸n, ofreciendo una gran flexibilidad en el manejo de datos.
        </p>
        <p>
          Para este tipo de direccionamiento, los registros que pueden ser
          utilizados para almacenar la direcci贸n de memoria son los registros
          base o 铆ndice (<code>BX</code>, <code>BP</code>, <code>SI</code> y
          <code>DI</code>).
        </p>
        <pre><code language="language-nasm" class="language-nasm">  MOV BP, 210h ; Se almacena la direcci贸n de memoria a acceder
  MOV AL, [BP] ; Se obtiene el valor que se encuentra en esa direcci贸n de memoria
</code></pre>
        <p>
          En el ejemplo anterior, en la direcci贸n hexadecimal
          <code>210</code> se encuentra cargado el valor hexadecimal
          <code>41</code> , posteriormente se carga dicha direcci贸n de memoria
          en el registro base <code>BP</code> con el cual se hace el
          direccionamiento indirecto para obtener el valor guardado en la
          direcci贸n <code>210</code> y se guarda en el registro
          <code>AL</code> , el cual finalmente obtiene el valor hexadecimal
          <code>41</code> .
        </p>
      </google-codelab-step>

      <google-codelab-step label="Tarea" duration="0">
        <p>
          Haciendo uso de los cuatro modos de direccionamientos abordados en
          esta gu铆a de laboratorio, se deber谩 almacenar el n煤mero de carn茅 del
          autor, colocando cada d铆gito en direcciones de memoria consecutivas,
          comenzando desde la direcci贸n <code>200h</code> . Es importante que
          para cada direccionamiento realizado se deje indicado utilizando
          comentarios a qu茅 tipo de direccionamiento corresponde.
        </p>
        <p>
          Por ejemplo, para el alumno con carn茅 <code>00124521</code> el
          resultado final esperado es el siguiente:
        </p>
        <p class="image-container">
          <img alt="Debug" src="img/657ab2fd9d45ad1a.png" />
        </p>
      </google-codelab-step>

      <google-codelab-step label="Indicaciones de entrega" duration="0">
        <ul>
          <li>
            La entrega se realizar谩 a trav茅s de GitHub Classroom, en el
            repositorio asignado para las
            <a href="https://classroom.github.com/a/p3Yq-RKA" target="_blank"
              >pr谩cticas de laboratorio</a
            >.
          </li>
          <li>
            Crear una carpeta llamada &#34;Laboratorio-03&#34; dentro del
            repositorio. Esta carpeta ser谩 el contenedor para los archivos de
            esta pr谩ctica.
          </li>
          <li>
            Dentro de la carpeta &#34;Laboratorio-03&#34;, crear un archivo
            llamado <strong><code>desarrollo.asm</code></strong
            >. En este archivo, colocar todos los ejemplos y ejercicios
            desarrollados durante la pr谩ctica de laboratorio.
          </li>
          <li>
            Crear un segundo archivo llamado
            <strong><code>tarea.asm</code></strong> dentro de la carpeta
            &#34;Laboratorio-03&#34;. Este archivo debe contener la soluci贸n a
            la tarea propuesta.
          </li>
        </ul>
        <pre><code> Laboratorio-03
     desarrollo.asm
     tarea.asm
</code></pre>
        <ul>
          <li>
            Realizar dos commits separados:
            <ul>
              <li>
                <strong>Primer Commit:</strong> Subir el archivo
                <strong><code>desarrollo.asm</code></strong> una vez completado
                el desarrollo durante la pr谩ctica.
              </li>
              <li>
                <strong>Segundo Commit:</strong> Subir el archivo
                <strong><code>tarea.asm</code></strong> una vez completada la
                tarea propuesta.
              </li>
            </ul>
          </li>
          <li>
            Copiar el enlace de su repositorio en el entregable llamado
            &#34;[Nota] Laboratorio 03 - Introducci贸n a ensamblador y modos de
            direccionamiento&#34; correspondiente a la pr谩ctica de laboratorio
            que est谩 colocado en el e-campus.
          </li>
        </ul>
      </google-codelab-step>

      <google-codelab-step label="R煤brica" duration="0">
        <table>
          <tr>
            <td colspan="1" rowspan="1">
              <p><strong>Criterios</strong></p>
            </td>
            <td colspan="1" rowspan="1">
              <p><strong>Porcentaje</strong></p>
            </td>
          </tr>
          <tr>
            <td colspan="1" rowspan="1"><p>Desarrollo</p></td>
            <td colspan="1" rowspan="1"><p>30%</p></td>
          </tr>
          <tr>
            <td colspan="1" rowspan="1"><p>Tarea</p></td>
            <td colspan="1" rowspan="1"><p>50%</p></td>
          </tr>
          <tr>
            <td colspan="1" rowspan="1"><p>Entrega en GitHub</p></td>
            <td colspan="1" rowspan="1"><p>20%</p></td>
          </tr>
          <tr>
            <td colspan="1" rowspan="1">
              <p><strong>Total</strong></p>
            </td>
            <td colspan="1" rowspan="1">
              <p><strong>100%</strong></p>
            </td>
          </tr>
        </table>
      </google-codelab-step>
    </google-codelab>

    <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
    <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
    <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
    <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
    <script src="//support.google.com/inapp/api.js"></script>
    <script>
      const fabs = document.querySelector("#fabs");
      const done = document.querySelector("#done");
      const codelabNavButtons = document.querySelector("#codelab-nav-buttons");
      const arrowBack = document.querySelector("#arrow-back");
      fabs.removeChild(done);
      codelabNavButtons.removeChild(arrowBack);
    </script>
  </body>
</html>
